package Model.APPS.UART_CONFIG.v4_0_12.Templates;

import Model.APPS.UART_CONFIG.v4_0_12.UART_CONFIG

out.print("""
/**
 * @file uart_config_conf.c
 * @date 2017-11-10
 *
 * NOTE:
 * This file is generated by DAVE-4. Any manual modification done to this file will be lost when the code is 
 * regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-07-11:
 *     - Initial version for DAVEv4
 *
 * 2015-08-19:
 *     - Removed internal pad consumption
 *
 * 2015-08-28:
 *     - Added support for BRG from external frequency input
 *
 * 2017-11-10:
 *     - Renamed UART_CONFIG_t to UART_CH_CONFIG_t to avoid clash when using simultaneously UART and UART_CONFIG APP.
 *
 * @endcond
 *
 */
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "uart_config.h"

/***********************************************************************************************************************
 * EXTERN DECLARATIONS
 **********************************************************************************************************************/

""")

/* Local lists holding diferent values */

List uart_mode = /* UART operation mode */
[
  "UART_CONFIG_MODE_FULLDUPLEX",
  "UART_CONFIG_MODE_HALFDUPLEX",
  "UART_CONFIG_MODE_LOOPBACK",
  "UART_CONFIG_MODE_IRDA"
]


List fifo_size = /* FIFO sizes list */
[
  "XMC_USIC_CH_FIFO_DISABLED",
  "XMC_USIC_CH_FIFO_SIZE_2WORDS",
  "XMC_USIC_CH_FIFO_SIZE_4WORDS",
  "XMC_USIC_CH_FIFO_SIZE_8WORDS",
  "XMC_USIC_CH_FIFO_SIZE_16WORDS",
  "XMC_USIC_CH_FIFO_SIZE_32WORDS",
  "XMC_USIC_CH_FIFO_SIZE_64WORDS"
]

List stop_bits = /* Number of stop bits */
[
  1,
  2
]

List parity_mode = /* Parity mode */
[
  "XMC_USIC_CH_PARITY_MODE_NONE",
  "XMC_USIC_CH_PARITY_MODE_EVEN",
  "XMC_USIC_CH_PARITY_MODE_ODD"
]

Map input_combination_mode = [
  'Rising Edge'  : 'XMC_USIC_CH_INPUT_COMBINATION_MODE_RISING_EDGE',
  'Falling Edge' : 'XMC_USIC_CH_INPUT_COMBINATION_MODE_FALLING_EDGE',
  'Both Edges'   : 'XMC_USIC_CH_INPUT_COMBINATION_MODE_BOTH_EDGES'
]

List protocol_events = /* UART protocol specific events list */
[
  "XMC_UART_CH_EVENT_BAUD_RATE_GENERATOR",
  "XMC_UART_CH_EVENT_SYNCHRONIZATION_BREAK",
  "XMC_UART_CH_EVENT_COLLISION",
  "XMC_UART_CH_EVENT_RECEIVER_NOISE",
  "XMC_UART_CH_EVENT_FORMAT_ERROR",
  "XMC_UART_CH_EVENT_FRAME_FINISHED",
  "XMC_UART_CH_EVENT_DATA_LOST",
]

for (UART_CONFIG appInst : appInstancesList ) {
  List usic_ch_uri = null             /* Used for holding USIC channel resource assigned by solver. */
  String appLabel = appInst.getInstanceLabel()   /* Get the name provided for APP instance. */  

  /* Get the resources consumed by the APP and assign them to the list variables */
  usic_ch_uri = appInst.hwres_usic_channel.getSolverUri()

  /* If the channel resource is available */
  if (usic_ch_uri != null) {
    /* Local strings to hold resource values derived from the URI */
    String ModuleInst,         /* USIC module number */
         ChannelInst         /* USIC channel number in the module */
         
    ModuleInst  = usic_ch_uri[4]    /* USIC module number */
    ChannelInst = usic_ch_uri[6]   /* USIC channel number in the module */
    
    boolean isfamily_4x = daveEnv.project.selectedDevice.deviceId.family == "XMC4",
        isfamily_1x = daveEnv.project.selectedDevice.deviceId.family == "XMC1",
        is_LoopBack_mode = appInst.gcombo_operation_mode.value == "Loop Back",
        is_IrDA_mode = appInst.gcombo_operation_mode.value == "IrDA",
        is_txFIFO_enabled = appInst.gcombo_number_tx_fifo_entries.value != "0",
        is_rxFIFO_enabled = appInst.gcombo_number_rx_fifo_entries.value != "0",
        uses_DX0 = (appInst.gcombo_operation_mode.value == "Half Duplex" ||
          appInst.gcombo_operation_mode.value == "IrDA") ||
          appInst.gcombo_operation_mode.value == "Full Duplex",
        uses_DX1 = ((appInst.gcombo_operation_mode.value == "Half Duplex" ||
        appInst.gcombo_operation_mode.value == "IrDA") &&
          appInst.gcombo_dx1_input_stage.value == "Collision Detection") ||
          (appInst.gcombo_operation_mode.value != "Loop Back" &&
          appInst.gcombo_dx1_input_stage.value == "External Frequency Input"),
        uses_DX2 = appInst.gcheck_enable_transmit_enable.value == true,
        uses_Internal_Clock = appInst.gcombo_clock_selection.value == "Internal Source (FD)",
        uses_External_Clock = appInst.gcombo_clock_selection.value == "External Source (DX1T)",
        is_any_protocol_event_enabled = (
          (appInst.gcheck_baud_rate_event.value == true) ||          /**< Baudrate generator event */
          ((appInst.gcombo_operation_mode.value == "Half Duplex")
            && (appInst.gcheck_collision_detection_event.value == true)) ||  /**< Collision event */
          (appInst.gcheck_receiver_noise_detection_event.value == true) ||  /**< Receiver noise event */
          (appInst.gcheck_format_error_event.value == true) ||        /**< Format error event */
          (appInst.gcheck_frame_finished_event.value == true) ||      /**< Transmitter/Receiver frame finished event */
		  (appInst.gcheck_datalost.value == true))                    /**< Data lost event*/

    int baud_rate = (uses_Internal_Clock) ? appInst.ginteger_desired_baud_rate.value : 0;
    List protocol_events_selection =  /* UART protocol specific events selected list */
    [
      (appInst.gcheck_baud_rate_event.value == true),
      (appInst.gcheck_synchronization_break_detection_event.value == true),
      ((appInst.gcheck_collision_detection_event.enabled == true) && (appInst.gcheck_collision_detection_event.value == true)),
      (appInst.gcheck_receiver_noise_detection_event.value == true),
      (appInst.gcheck_format_error_event.value == true),
	  (appInst.gcheck_frame_finished_event.value == true),
      (appInst.gcheck_datalost.value == true)
    ]

    /**********************************Dummy read*************************************/
    appInst.hwres_usic_channel.getRegValue("INPR","inpr_pinp")
    appInst.hwres_usic_channel.getRegValue("DX0CR","dx0cr_dsel")
    appInst.hwres_usic_channel.getRegValue("DX3CR","dx3cr_dsel")
    appInst.hwres_usic_channel.getRegValue("DX4CR","dx4cr_dsel")
    appInst.hwres_usic_channel.getRegValue("DX5CR","dx5cr_dsel")
    /*********************************************************************************/
    
    
    out.print("""
/***********************************************************************************************************************
 * FUNCTION PROTOTYPES
 **********************************************************************************************************************/
/* USIC channel initialization function */
void ${appLabel}_lInit(void);


/***********************************************************************************************************************
 * DATA STRUCTURES
 **********************************************************************************************************************/

/* USIC channel configuration for UART */
const XMC_UART_CH_CONFIG_t ${appLabel}_channel_config =
{""")
    out.print("""
  .baudrate      = ${baud_rate}U,
  .data_bits     = ${appInst.ginteger_word_length.value}U,
  .frame_length  = ${appInst.ginteger_frame_length.value}U,""")
    int stop_bit_index = appInst.gcombo_stop_bits.options.indexOf(appInst.gcombo_stop_bits.value)
    out.print("""
  .stop_bits     = ${stop_bits[stop_bit_index]}U,
  .oversampling  = ${appInst.ginteger_oversampling.value}U,""")
    int parity_mode_index = appInst.gcombo_parity.options.indexOf(appInst.gcombo_parity.value)
    out.print("""
  .parity_mode   = ${parity_mode[parity_mode_index]}
};

/* UART APP configuration structure */
const UART_CONFIG_CONF_t ${appLabel}_config = 
{
  .channel_config   = &${appLabel}_channel_config,
  .sample_point = ${appInst.ginteger_sample_point.value}U,
  .pulse_length = ${appInst.ginteger_pulse_length.value}U,
  .uart_config_init = ${appLabel}_lInit,""")
    int uart_mode_index = appInst.gcombo_operation_mode.options.indexOf(appInst.gcombo_operation_mode.value)
    out.print("""
  .mode = ${uart_mode[uart_mode_index]},""")
    if (is_txFIFO_enabled) {
      Integer FIFO_size = appInst.hwres_usic_channel.getRegValue("TBCTR","tbctr_size")
      Integer FIFO_limit = appInst.ginteger_limit_for_transmit_events.value
      out.print("""
  .tx_fifo_size     = ${fifo_size[FIFO_size]},
  .tx_fifo_limit     = ${FIFO_limit}U,""")
    } else {
      out.print("""
  .tx_fifo_size     = XMC_USIC_CH_FIFO_DISABLED,
  .tx_fifo_limit     = 0U,""")
    }
    if (is_rxFIFO_enabled) {
      Integer FIFO_size = appInst.hwres_usic_channel.getRegValue("TBCTR","rbctr_size")
      Integer FIFO_limit = appInst.ginteger_limit_for_receive_events.value
      out.print("""
  .rx_fifo_size     = ${fifo_size[FIFO_size]},
  .rx_fifo_limit     = ${FIFO_limit}U""")
    } else {
      out.print("""
  .rx_fifo_size     = XMC_USIC_CH_FIFO_DISABLED,
  .rx_fifo_limit     = 0U""")
    }
    out.print("""
};
""")
    /* Write APP handle structure */
    out.print("""
/* APP handle structure */
UART_CH_CONFIG_t ${appLabel} = 
{
  .channel = XMC_UART${ModuleInst}_CH${ChannelInst},
  .config  = &${appLabel}_config
};
""")

    /* Define a variable with the bit mask of enabled uart-specific events */
    if(is_any_protocol_event_enabled) {
      out.print("""
/* Enabled protocol events */""")
      out.print("""
const uint32_t ${appLabel}_enabled_protocol_events = (""")
      event_index = 0
      event_mask = ""
      for(event_index = 0; event_index <= 6; event_index++)
      {
        if(protocol_events_selection[event_index] == true) {
          if(event_mask != "") {
            event_mask += " | "
          }
          event_mask += "(uint32_t)" + protocol_events[event_index]
        }
      }
      out.print(event_mask)
      out.print(""");""")
    }

    /* Write the init function definition */
    out.print("""
/***********************************************************************************************************************
 * API IMPLEMENTATION
 **********************************************************************************************************************/
/* Channel initialization function */
void ${appLabel}_lInit()
{""")
    out.print("""
  /* Initialize USIC channel in UART mode */
  XMC_UART_CH_Init(XMC_UART${ModuleInst}_CH${ChannelInst}, &${appLabel}_channel_config);""")
    if (appInst.gcheck_enable_capture_mode_timer.value == true) {
        out.print("""
  /* Enable the capture mode timer */
  XMC_USIC_CH_EnableTimeMeasurement(XMC_UART${ModuleInst}_CH${ChannelInst});""")
    }
    if(uses_DX2) {
      int type_transmit_data_validation_index = appInst.gcombo_type_transmit_data_validation.options.indexOf(appInst.gcombo_type_transmit_data_validation.value)
      switch(type_transmit_data_validation_index) {
        case 0:
          out.print("""
  /*Enable transmission when TDV = 1 and DX2S = 0*/
  XMC_USIC_CH_SetStartTransmisionMode(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_START_TRANSMISION_ON_TDV_DX2S_0);
""")
          break;
        case 1:
          out.print("""
  /*Enable transmission when TDV = 1 and DX2S = 1*/
  XMC_USIC_CH_SetStartTransmisionMode(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_START_TRANSMISION_ON_TDV_DX2S_1);
""")
          break;
        case 2:
          out.print("""
  /*Enable transmission when TDV = 1 and the selected edge of the DX2 signal occurs*/
  XMC_USIC_CH_SetInputTriggerCombinationMode(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INPUT_DX2, 
                                             ${input_combination_mode[appInst.gcombo_transmit_data_validation_trigger_edge.value]});
  ${appLabel}.channel->TCSR |= (uint32_t)USIC_CH_TCSR_TDVTR_Msk;""")
          break;
      }
    }
    out.print("""
  /* Set the Sample Point */
  XMC_UART_CH_SetSamplePoint(XMC_UART${ModuleInst}_CH${ChannelInst}, ${appInst.ginteger_sample_point.value}U);""")
    if (is_IrDA_mode) {
      out.print("""
  /* Set the Pulse Length */
  XMC_UART_CH_SetPulseLength(XMC_UART${ModuleInst}_CH${ChannelInst}, ${appInst.ginteger_pulse_length.value}U);""")
    }
    if(is_LoopBack_mode) {
      out.print("""
  /* Set input source for input stage dx0 (receive pin) */
  XMC_USIC_CH_SetInputSource(XMC_UART${ModuleInst}_CH${ChannelInst}, (XMC_USIC_CH_INPUT_t)XMC_UART_CH_INPUT_RXD, ${appInst.hwres_usic_channel.getRegValue("dx0cr","dx0cr_dsel")}U);""")
      if(isfamily_1x) {
        /* XMC1000 devices can use the DX3 and DX5 input stages as additional sources of input for rx (dx0) */
        out.print("""
  XMC_USIC_CH_SetInputSource(XMC_UART${ModuleInst}_CH${ChannelInst}, (XMC_USIC_CH_INPUT_t)XMC_UART_CH_INPUT_RXD1, ${appInst.hwres_usic_channel.getRegValue("dx3cr","dx3cr_dsel")}U);""")
      }
    }
    if(uses_DX0) {
      out.print("""
  /* Set input source for input stage dx0 (receive pin) */
  XMC_USIC_CH_SetInputSource(XMC_UART${ModuleInst}_CH${ChannelInst}, (XMC_USIC_CH_INPUT_t)XMC_UART_CH_INPUT_RXD, ${appInst.hwres_usic_channel.getRegValue("dx0cr","dx0cr_dsel")}U);""")
      if(isfamily_1x) {
        /* XMC1000 devices can use the DX3 and DX5 input stages as additional sources of input for rx (dx0) */
        out.print(""" 
  XMC_USIC_CH_SetInputSource(XMC_UART${ModuleInst}_CH${ChannelInst}, (XMC_USIC_CH_INPUT_t)XMC_UART_CH_INPUT_RXD1, ${appInst.hwres_usic_channel.getRegValue("dx3cr","dx3cr_dsel")}U);
  XMC_USIC_CH_SetInputSource(XMC_UART${ModuleInst}_CH${ChannelInst}, (XMC_USIC_CH_INPUT_t)XMC_UART_CH_INPUT_RXD2, ${appInst.hwres_usic_channel.getRegValue("dx5cr","dx5cr_dsel")}U);""")
      }
    }
    if(uses_DX1) {
      out.print("""
  /* Set input source for input stage dx1 (collision detection) */
  XMC_USIC_CH_SetInputSource(XMC_UART${ModuleInst}_CH${ChannelInst}, (XMC_USIC_CH_INPUT_t)XMC_USIC_CH_INPUT_DX1, ${appInst.hwres_usic_channel.getRegValue("dx1cr","dx1cr_dsel")}U);""")
    }
    if(uses_DX2) {
      out.print("""
  /* Set input source for input stage dx2 (transmit data validation) */
  XMC_USIC_CH_SetInputSource(XMC_UART${ModuleInst}_CH${ChannelInst}, (XMC_USIC_CH_INPUT_t)XMC_USIC_CH_INPUT_DX2, ${appInst.hwres_usic_channel.getRegValue("dx2cr","dx2cr_dsel")}U);""")
    }
    if (uses_External_Clock) {
      out.print("""
  /* Set the dividers registers to generate the baud rate from an external clock source */
  XMC_USIC_CH_ConfigExternalInputSignalToBRG(XMC_UART${ModuleInst}_CH${ChannelInst}, ${appInst.ginteger_divider_factor_external_clk.value}U, ${appInst.ginteger_oversampling.value}U, ${input_combination_mode[appInst.gcombo_external_clock_edge.value]});
  XMC_USIC_CH_SetBRGInputClockSource(XMC_UART${ModuleInst}_CH${ChannelInst}, (XMC_USIC_CH_BRG_CLOCK_SOURCE_t)(0x2UL << USIC_CH_BRG_CLKSEL_Pos));
  XMC_USIC_CH_SetInputTriggerCombinationMode(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INPUT_DX1, 
                                             ${input_combination_mode[appInst.gcombo_external_clock_edge.value]});
  XMC_UART${ModuleInst}_CH${ChannelInst}->BRG = (XMC_UART${ModuleInst}_CH${ChannelInst}->BRG & (uint32_t)(~(USIC_CH_BRG_DCTQ_Msk |
                                    USIC_CH_BRG_PDIV_Msk |
                                    USIC_CH_BRG_PCTQ_Msk |
                                    USIC_CH_BRG_PPPEN_Msk))) |
                   (uint32_t)((uint32_t)((${appInst.ginteger_oversampling.value}U) - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((uint32_t)((uint32_t)((${appInst.ginteger_divider_factor_external_clk.value}U) - 1U) << USIC_CH_BRG_PDIV_Pos));""")

    }
    if (is_txFIFO_enabled) {
      Integer FIFO_size = appInst.hwres_usic_channel.getRegValue("TBCTR", "tbctr_size")
      Integer FIFO_limit = appInst.ginteger_limit_for_transmit_events.value
      Integer FIFO_data_pointer = appInst.hwres_usic_channel.getRegValue("TBCTR", "tbctr_dptr")
      out.print("""
  /* Configure the transmit FIFO */
  XMC_USIC_CH_TXFIFO_Configure(${appLabel}.channel, ${FIFO_data_pointer}U, ${fifo_size[FIFO_size]}, ${FIFO_limit}U);""")
    }
    if (is_rxFIFO_enabled) {
      Integer FIFO_size = appInst.hwres_usic_channel.getRegValue("RBCTR", "rbctr_size")
      Integer FIFO_limit = appInst.ginteger_limit_for_receive_events.value
      Integer FIFO_data_pointer = appInst.hwres_usic_channel.getRegValue("RBCTR", "rbctr_dptr")
      out.print("""
  /* Configure the receive FIFO */
  XMC_USIC_CH_RXFIFO_Configure(${appLabel}.channel, ${FIFO_data_pointer}U, ${fifo_size[FIFO_size]}, ${FIFO_limit}U);""")

    }

    if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_tsien") == 1) {
      int transmit_shift_event_sr = appInst.hwres_usic_channel.getRegValue("inpr","inpr_tsinp")
      out.print("""
  /* Set the service request line for the transmit shift event */
  XMC_USIC_CH_SetInterruptNodePointer(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT, ${transmit_shift_event_sr}U);""")
    }
    if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_tbien") == 1 || appInst.hwres_usic_channel.getRegValue("ccr","ccr_rsien") == 1) {
      int transmit_buffer_event_sr = appInst.hwres_usic_channel.getRegValue("inpr","inpr_tbinp")
      out.print("""
  /* Set the service request line for the transmit buffer event */
  XMC_USIC_CH_SetInterruptNodePointer(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER, ${transmit_buffer_event_sr}U);""")
    }
    if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_rien") == 1) {
      int standard_receive_event_sr = appInst.hwres_usic_channel.getRegValue("inpr","inpr_rinp")
      out.print("""
  /* Set the service request line for the standard receive event */
  XMC_USIC_CH_SetInterruptNodePointer(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INTERRUPT_NODE_POINTER_RECEIVE, ${standard_receive_event_sr}U);""")
    }
    if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_aien") == 1) {
      int alternative_receive_event_sr = appInst.hwres_usic_channel.getRegValue("inpr","inpr_ainp")
        out.print("""
  /* Set the service request line for the alternative receive event */
  XMC_USIC_CH_SetInterruptNodePointer(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INTERRUPT_NODE_POINTER_ALTERNATE_RECEIVE, ${alternative_receive_event_sr}U);""")
    }
      int protocol_events_sr = appInst.hwres_usic_channel.getRegValue("inpr","inpr_pinp")
      out.print("""
  /* Set the service request line for the Data Lost, Baud Rate Generator and UART protocol events */
  XMC_USIC_CH_SetInterruptNodePointer(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL, ${protocol_events_sr}U);""")
    if(is_txFIFO_enabled) {
        if(appInst.hwres_usic_channel.getRegValue("tbctr","tbctr_stbien") == 1) {
          int standard_transmit_buffer_event_sr = appInst.hwres_usic_channel.getRegValue("tbctr","tbctr_stbinp")
          out.print("""
  /* Set the service request line for the standard transmit buffer event */
  XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_STANDARD, ${standard_transmit_buffer_event_sr}U);""")
        }
        if(appInst.hwres_usic_channel.getRegValue("tbctr","tbctr_tberien") == 1) {
          int transmit_buffer_error_event_sr = appInst.hwres_usic_channel.getRegValue("tbctr","tbctr_atbinp")
          out.print("""
  /* Set the service request line for the transmit buffer error event */
  XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE, ${transmit_buffer_error_event_sr}U);""")
        }
      }
      if(is_rxFIFO_enabled) {
        if(appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_srbien") == 1) {
          int standard_receive_buffer_event_sr = appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_srbinp")
          out.print("""
  /* Set the service request line for the standard receive buffer event */
  XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_STANDARD, ${standard_receive_buffer_event_sr}U);""")
        }
      if((appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_arbien") == 1) ||
		  (appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_rberien") == 1)) {
        int alternative_receive_buffer_event_sr = appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_arbinp")
        out.print("""
  /* Set the service request line for the alternative receive buffer / receive buffer error event */
  XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE, ${alternative_receive_buffer_event_sr}U);""")
      }
    }
  if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_rsien") == 1) {
  out.print("""
  /* Enable the receive start event */
  XMC_USIC_CH_EnableEvent(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_EVENT_RECEIVE_START);""")
    }
    if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_tsien") == 1) {
      out.print("""
  /* Enable the transmit shift event */
  XMC_USIC_CH_EnableEvent(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_EVENT_TRANSMIT_SHIFT);""")
    }
    if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_tbien") == 1) {
      out.print("""
  /* Enable the transmit buffer event */
  XMC_USIC_CH_EnableEvent(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);""")
    }
    if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_rien") == 1) {
      out.print("""
  /* Enable the standard receive event */
  XMC_USIC_CH_EnableEvent(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_EVENT_STANDARD_RECEIVE);""")
    }
    if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_aien") == 1) {
      out.print("""
  /* Enable the alternative event */
  XMC_USIC_CH_EnableEvent(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE);""")
    }
    if(is_txFIFO_enabled) {
      if(appInst.hwres_usic_channel.getRegValue("tbctr","tbctr_stbien") == 1) {
        out.print("""
  /* Enable the standard transmit buffer event */
  XMC_USIC_CH_TXFIFO_EnableEvent(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);""")  
      }
      if(appInst.hwres_usic_channel.getRegValue("tbctr","tbctr_tberien") == 1) {
        out.print("""
  /* Enable the transmit buffer error event */
  XMC_USIC_CH_TXFIFO_EnableEvent(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_TXFIFO_EVENT_CONF_ERROR);""")  
      }
    }
    if(is_rxFIFO_enabled) {
      if(appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_srbien") == 1) {
        out.print("""
  /* Enable the standard receive buffer event */
  XMC_USIC_CH_RXFIFO_EnableEvent(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD);""")  
      }
      if(appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_rberien") == 1) {
        out.print("""
 /* Enable the receive buffer error event */
  XMC_USIC_CH_RXFIFO_EnableEvent(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_RXFIFO_EVENT_CONF_ERROR);""")  
      }
      if(appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_arbien") == 1) {
        out.print("""
 /* Enable the alternative receive buffer event */
  XMC_USIC_CH_RXFIFO_EnableEvent(XMC_UART${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE);""")  
      }
    }
    if(is_any_protocol_event_enabled) {
      out.print("""
  /* Enable the UART protocol-specific events (PCR_ASCMode register) */
  XMC_UART_CH_EnableEvent(XMC_UART${ModuleInst}_CH${ChannelInst}, ${appLabel}_enabled_protocol_events);""")
    }  
    out.print("""
}""")
  } /* if the channel resource is available */
} /* For all instances */

out.print("""
/* CODE_BLOCK_END */
""")
