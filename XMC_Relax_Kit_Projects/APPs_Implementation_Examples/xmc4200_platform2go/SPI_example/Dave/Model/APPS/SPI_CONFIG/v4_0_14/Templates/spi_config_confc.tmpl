package Model.APPS.SPI_CONFIG.v4_0_14.Templates;

import Model.APPS.SPI_CONFIG.v4_0_14.SPI_CONFIG

out.print("""
/**
 * @file spi_config_conf.c
 * @date 2015-08-28
 *
 * NOTE:
 * This file is generated by DAVE-4. Any manual modification done to this file will be lost when the code is
 * regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 *
 * Copyright (c) 2015-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-08-06:
 *     - Initial version for DAVEv4
 *
 * 2015-08-28:
 *     - Added support for BRG from external frequency input
 *
 * 2016-01-08:
 *     - code size and functionality are improved
 *
 * @endcond
 *
 */
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "spi_config.h"

/***********************************************************************************************************************
 * EXTERN DECLARATIONS
 **********************************************************************************************************************/

""")

/*----- GTab: General -----*/
// GGroup: Operation Mode
Map device_type = [
	'Master'    : 'XMC_SPI_CH_BUS_MODE_MASTER',
	'Slave'     : 'XMC_SPI_CH_BUS_MODE_SLAVE'
]

Map operation_mode = [
	'Half Duplex'                : 'XMC_SPI_CH_MODE_STANDARD_HALFDUPLEX',
	'Full Duplex'                : 'XMC_SPI_CH_MODE_STANDARD',
	'Dual SPI'                   : 'XMC_SPI_CH_MODE_DUAL',
	'Quad SPI'                   : 'XMC_SPI_CH_MODE_QUAD',
	'Loop Back'                  : 'XMC_SPI_CH_MODE_STANDARD'
]

// GGroup: Frame format
Map parity_mode = [
	'No Parity'   : 'XMC_USIC_CH_PARITY_MODE_NONE',
	'Even Parity' : 'XMC_USIC_CH_PARITY_MODE_EVEN',
	'Odd Parity'  : 'XMC_USIC_CH_PARITY_MODE_ODD'
]


/*----- GTab: Shift Clock -----*/
// GGroup: Baud Rate Generator
Map input_combination_mode = [
	'Rising Edge'  : 'XMC_USIC_CH_INPUT_COMBINATION_MODE_RISING_EDGE',
	'Falling Edge' : 'XMC_USIC_CH_INPUT_COMBINATION_MODE_FALLING_EDGE',
	'Both Edges'   : 'XMC_USIC_CH_INPUT_COMBINATION_MODE_BOTH_EDGES'
]

// GGroup: Shift Clock Signal
Map shift_clock_settings = [
	'No Delay, No Polarity Inversion' : 'XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_DISABLED',
	'Delayed By 1/2 Shift Clock Period, No Polarity Inversion' : 'XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_ENABLED',
	'Delayed By 1/2 Shift Clock Period, Polarity Inversion' : 'XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_ENABLED',
	'No Delay, Polarity Inversion' : 'XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_DISABLED'
]

/*----- GTab: Slave Select -----*/
Map slave_select_lines = [
	0 : 'XMC_SPI_CH_SLAVE_SELECT_0',
	1 : 'XMC_SPI_CH_SLAVE_SELECT_1',
	2 : 'XMC_SPI_CH_SLAVE_SELECT_2',
	3 : 'XMC_SPI_CH_SLAVE_SELECT_3',
	4 : 'XMC_SPI_CH_SLAVE_SELECT_4',
	5 : 'XMC_SPI_CH_SLAVE_SELECT_5',
	6 : 'XMC_SPI_CH_SLAVE_SELECT_6',
	7 : 'XMC_SPI_CH_SLAVE_SELECT_7'
]

Map slave_select_resource =[
	'selo0' : 'XMC_SPI_CH_SLAVE_SELECT_0',
	'selo1' : 'XMC_SPI_CH_SLAVE_SELECT_1',
	'selo2' : 'XMC_SPI_CH_SLAVE_SELECT_2',
	'selo3' : 'XMC_SPI_CH_SLAVE_SELECT_3',
	'selo4' : 'XMC_SPI_CH_SLAVE_SELECT_4',
	'selo5' : 'XMC_SPI_CH_SLAVE_SELECT_5',
	'selo6' : 'XMC_SPI_CH_SLAVE_SELECT_6',
	'selo7' : 'XMC_SPI_CH_SLAVE_SELECT_7'
	]
Map select_control = [
	'Coded' : '0U',
	'Direct' : 'USIC_CH_PCR_SSCMode_SELCTR_Msk'
]


Map slave_select_delay_input_freq = [
	0 : 'XMC_SPI_CH_INPUT_FREQ_SLAVE_SELECT_DELAY_FPDIV',
	1 : 'XMC_SPI_CH_INPUT_FREQ_SLAVE_SELECT_DELAY_FPPP',
	2 : 'XMC_SPI_CH_INPUT_FREQ_SLAVE_SELECT_DELAY_FSCLK',
	3 : 'XMC_SPI_CH_INPUT_FREQ_SLAVE_SELECT_DELAY_FMCLK'
]

/*----- GTab: Events -----*/
// GGroup: Protocol Events
List protocol_events = [
	"XMC_SPI_CH_EVENT_MSLS_CHANGE",
	"XMC_SPI_CH_EVENT_DX2TIEN_ACTIVATED",
	"XMC_SPI_CH_EVENT_PARITY_ERROR",
	"XMC_SPI_CH_EVENT_BAUD_RATE_GENERATOR",
	"XMC_SPI_CH_EVENT_DATA_LOST"
]

/*----- GTab: FIFO -----*/
// GGroups: Tx/Rx FIFO Buffer Configuration
Map fifo_size = [
	0 : 'XMC_USIC_CH_FIFO_DISABLED',
	1 : 'XMC_USIC_CH_FIFO_SIZE_2WORDS',
	2 : 'XMC_USIC_CH_FIFO_SIZE_4WORDS',
	3 : 'XMC_USIC_CH_FIFO_SIZE_8WORDS',
	4 : 'XMC_USIC_CH_FIFO_SIZE_16WORDS',
	5 : 'XMC_USIC_CH_FIFO_SIZE_32WORDS',
	6 : 'XMC_USIC_CH_FIFO_SIZE_64WORDS'
]

List slave_select_port_handlers = ['NULL','NULL','NULL','NULL','NULL','NULL','NULL','NULL']
for (SPI_CONFIG appInst : appInstancesList ) {
	List USIC_ChannelUri = appInst.hwres_usic_channel.getSolverUri() 	// USIC channel resource assigned by solver
	
	/* If the channel resource is available */
	if (USIC_ChannelUri != null) {
		/* Resources values derived from the URI */
		String appLabel,				// Name provided for APP instance
			   ModuleInst, 				// USIC module number
			   ChannelInst 				// USIC channel number in the module
		appLabel = appInst.getInstanceLabel()
		
		boolean isfamily_4x = daveEnv.project.selectedDevice.deviceId.family == "XMC4",
				isfamily_1x = daveEnv.project.selectedDevice.deviceId.family == "XMC1",
				isDeviceMaster = appInst.gcombo_device_type.value == "Master",
				isDeviceSlave = appInst.gcombo_device_type.value == "Slave",
				isntModeLoopBack = appInst.gcombo_operation_mode.value != "Loop Back",
				isntModeHalfDuplex = !(appInst.gcombo_operation_mode.value ==~ "Half Duplex.*"),
				isModeHalfDuplex = appInst.gcombo_operation_mode.value == "Half Duplex",
				isModeFullDuplex = appInst.gcombo_operation_mode.value == "Full Duplex",
				isModeDualSPI = appInst.gcombo_operation_mode.value == "Dual SPI",
				isModeQuadSPI = appInst.gcombo_operation_mode.value == "Quad SPI",
				isDelayCompensationEnabled = appInst.gcheck_enable_delay_compensation_master.value,
				isDelayCompensationEnabled_slave = appInst.gcheck_enable_delay_compensation_slave.value,
				usesDX1 = appInst.gcombo_device_type.value == "Slave" ||
						(
							appInst.gcombo_device_type.value == "Master" &&
							appInst.gcombo_dx1_input_stage_master.value != "None"
						),
				usesDX2 = appInst.gcombo_device_type.value == "Slave" ||
						(
							appInst.gcombo_device_type.value == "Master" &&
							appInst.gcombo_dx2_input_stage_master.value != "None"
						),
				isTDVEnabled = appInst.gcombo_device_type.value == "Master" &&
						appInst.gcombo_dx2_input_stage_master.value == "Transmit Data Validation",
				enableDX1InputInversion = (
						appInst.gcombo_device_type.value == "Slave" ||
						(
							appInst.gcombo_device_type.value == "Master" &&
							appInst.gcombo_dx1_input_stage_master.value != "None"
						)
					) &&
					appInst.gcheck_enable_invert_dx1_input_stage.value == true,
				enableDX2InputInversion = (
						appInst.gcombo_device_type.value == "Slave" ||
						(
							appInst.gcombo_device_type.value == "Master" &&
							appInst.gcombo_dx2_input_stage_master.value != "None"
						)
					) &&
					appInst.gcheck_enable_invert_dx2_input_stage.value == true,
				enableOutputsInversion = (
						(
							appInst.gcombo_device_type.value == "Slave" &&
							appInst.gcombo_sclkout_output_slave.value != "None"
						) ||
						(
							appInst.gcombo_device_type.value == "Master" &&
							appInst.gcombo_sclkout_output_master.value != "None"
						)
					) &&
					appInst.gcheck_enable_invert_outputs.value == true,
				uses_Internal_Clock = appInst.gcombo_clock_selection.value == "Internal Source (FD)",
				uses_External_Clock = appInst.gcombo_clock_selection.value == "External Source (DX1T)",
				is_txFIFO_enabled = appInst.gcombo_number_tx_fifo_entries.value != "0",
				is_rxFIFO_enabled = appInst.gcombo_number_rx_fifo_entries.value != "0"
				is_any_protocol_event_enabled =
					(isDeviceMaster && appInst.gcheck_msls_event.value) ||			/**< MSLS event */
					appInst.gcheck_dx2_event.value ||			                    /**< DX2T event */
					appInst.gcheck_parity_error_event.value	||			            /**< Parity error event */
					appInst.gcheck_baud_rate_event.value  ||                        /**< Baudrate generator event */
					appInst.gcheck_datalost.value                                   /**< Datalost event */
			
		int baud_rate = 0;
		if (isDeviceMaster && uses_Internal_Clock)
			baud_rate = (int) ((appInst.gfloat_actual_baud_rate.value) * 1000);
		List protocol_events_selection =  /* SPI protocol specific events selected list */
		[
			isDeviceMaster && appInst.gcheck_msls_event.value,
			appInst.gcheck_dx2_event.value,
			appInst.gcheck_parity_error_event.value,
			appInst.gcheck_baud_rate_event.value,
			appInst.gcheck_datalost.value
		]
					
		ModuleInst  = USIC_ChannelUri[4]
		ChannelInst = USIC_ChannelUri[6]

		/**********************************Dummy read*************************************/
		appInst.hwres_usic_channel.getRegValue("INPR","inpr_pinp")
		appInst.hwres_usic_channel.getRegValue("DX0CR","dx3cr_dsel")
		appInst.hwres_usic_channel.getRegValue("DX3CR","dx3cr_dsel")
		appInst.hwres_usic_channel.getRegValue("DX4CR","dx4cr_dsel")
		appInst.hwres_usic_channel.getRegValue("DX5CR","dx5cr_dsel")
		/*********************************************************************************/
		slave_select_port_handlers[0]='(XMC_SPI_CH_SLAVE_SELECT_t)0U'
		slave_select_port_handlers[1]='(XMC_SPI_CH_SLAVE_SELECT_t)0U'
		slave_select_port_handlers[2]='(XMC_SPI_CH_SLAVE_SELECT_t)0U'
		slave_select_port_handlers[3]='(XMC_SPI_CH_SLAVE_SELECT_t)0U'
		slave_select_port_handlers[4]='(XMC_SPI_CH_SLAVE_SELECT_t)0U'
		slave_select_port_handlers[5]='(XMC_SPI_CH_SLAVE_SELECT_t)0U'
		slave_select_port_handlers[6]='(XMC_SPI_CH_SLAVE_SELECT_t)0U'
		slave_select_port_handlers[7]='(XMC_SPI_CH_SLAVE_SELECT_t)0U'
		if(appInst.gint_slave_select_lines.value > 0){
			if (slave_select_resource[appInst.sv_slave_select_0.getSolverValue()] != null)
			{
				slave_select_port_handlers[0] = slave_select_resource[appInst.sv_slave_select_0.getSolverValue()]
			}
		}
		if(appInst.gint_slave_select_lines.value > 1){
			if (slave_select_resource[appInst.sv_slave_select_1.getSolverValue()] != null)
			{
				slave_select_port_handlers[1] = slave_select_resource[appInst.sv_slave_select_1.getSolverValue()]
			}
		}
		if(appInst.gint_slave_select_lines.value > 2){
			if (slave_select_resource[appInst.sv_slave_select_2.getSolverValue()] != null)
			{
				slave_select_port_handlers[2] = slave_select_resource[appInst.sv_slave_select_2.getSolverValue()]
			}
		}
		if(appInst.gint_slave_select_lines.value > 3){
			if (slave_select_resource[appInst.sv_slave_select_3.getSolverValue()] != null)
			{
				slave_select_port_handlers[3] = slave_select_resource[appInst.sv_slave_select_3.getSolverValue()]
			}
		}
		if(appInst.gint_slave_select_lines.value > 4){
			if (slave_select_resource[appInst.sv_slave_select_4.getSolverValue()] != null)
			{
				slave_select_port_handlers[4] = slave_select_resource[appInst.sv_slave_select_4.getSolverValue()]
			}
		}
		if(appInst.gint_slave_select_lines.value > 5){
			if (slave_select_resource[appInst.sv_slave_select_5.getSolverValue()] != null)
			{
				slave_select_port_handlers[5] = slave_select_resource[appInst.sv_slave_select_5.getSolverValue()]
			}
		}
		if(appInst.gint_slave_select_lines.value > 6){
			if (slave_select_resource[appInst.sv_slave_select_6.getSolverValue()] != null)
			{
				slave_select_port_handlers[6] = slave_select_resource[appInst.sv_slave_select_6.getSolverValue()]
			}
		}
		if(appInst.gint_slave_select_lines.value > 7){
			if (slave_select_resource[appInst.sv_slave_select_7.getSolverValue()] != null)
			{
				slave_select_port_handlers[7] = slave_select_resource[appInst.sv_slave_select_7.getSolverValue()]
			}
		}
		out.print("""

/**********************************************************************************************************************
* FUNCTION PROTOTYPE
**********************************************************************************************************************/
/* USIC channel initialization function */
void ${appLabel}_lInit(void);
""");
out.print("""
/***********************************************************************************************************************
 * DATA STRUCTURES
 **********************************************************************************************************************/""")
if((isDeviceMaster)){
		out.print("""
/* Slave Select line mapping information */
const XMC_SPI_CH_SLAVE_SELECT_t ${appLabel}_slave_select_list[8] =
                                                        {${slave_select_port_handlers[0]}, ${slave_select_port_handlers[1]},
                                                        ${slave_select_port_handlers[2]}, ${slave_select_port_handlers[3]},
                                                        ${slave_select_port_handlers[4]}, ${slave_select_port_handlers[5]},
                                                        ${slave_select_port_handlers[6]}, ${slave_select_port_handlers[7]}};""")
		}

out.print("""

/* USIC channel configuration for SPI */
XMC_SPI_CH_CONFIG_t ${appLabel}_channel_config =
{
  .baudrate = ${baud_rate}U,
  .bus_mode = ${device_type[appInst.gcombo_device_type.value]},
  .selo_inversion = ${(appInst.gcheck_enable_invert_slave_select_signals.value == false) ? 'XMC_SPI_CH_SLAVE_SEL_SAME_AS_MSLS' : 'XMC_SPI_CH_SLAVE_SEL_INV_TO_MSLS'}, 
  .parity_mode = ${parity_mode[appInst.gcombo_parity.value]}
};

/* SPI_CONFIG APP configuration structure */
const SPI_CONFIG_CONF_t ${appLabel}_config = 
{
  .channel_config   = &${appLabel}_channel_config,
  .spi_config_init_func = ${appLabel}_lInit,
  .op_mode = ${operation_mode[appInst.gcombo_operation_mode.value]}, """)
		if (is_txFIFO_enabled) {
			Integer FIFO_size = appInst.hwres_usic_channel.getRegValue("TBCTR","tbctr_size")
			Integer FIFO_limit = appInst.ginteger_limit_for_transmit_events.value
			out.print("""
  .tx_fifo_size = ${fifo_size[FIFO_size]},
  .tx_fifo_limit = ${FIFO_limit}U,""")
		} else {
			out.print("""
  .tx_fifo_size = XMC_USIC_CH_FIFO_DISABLED,
  .tx_fifo_limit = 0U,""")
		}
		if (is_rxFIFO_enabled) {
			Integer FIFO_size = appInst.hwres_usic_channel.getRegValue("TBCTR","rbctr_size")
			Integer FIFO_limit = appInst.ginteger_limit_for_receive_events.value
			out.print("""
  .rx_fifo_size = ${fifo_size[FIFO_size]},
  .rx_fifo_limit = ${FIFO_limit}U,""")
		} else {
			out.print("""
  .rx_fifo_size = XMC_USIC_CH_FIFO_DISABLED,
  .rx_fifo_limit = 0U,""")
		}
		if(isDeviceMaster) {
			out.print("""
  /* Number of Slave Select line used */
  .num_slave_sel_lines = ${appInst.gint_slave_select_lines.value},
  /* Slave Select line mapping information */
  .slave_select_list  = ${appLabel}_slave_select_list, """)
		}
			if(isDeviceSlave) {
				out.print("""
  /* Number of Slave Select line used */
  .num_slave_sel_lines = 0U,
  /* Slave Select line mapping information */
  .slave_select_list = NULL,""")
			}
		out.print("""
};
""")
		/* Write APP handle structure */
		out.print("""
/* APP handle structure */
SPI_CONFIG_t ${appLabel} = 
{
  .channel = XMC_SPI${ModuleInst}_CH${ChannelInst},
  .config  = &${appLabel}_config
};
""")
		/* Define a variable with the bit mask of enabled SPI-specific events */
		if(is_any_protocol_event_enabled) {
			out.print("""
/* Enabled protocol events */""")
			out.print("""
const uint32_t ${appLabel}_enabled_protocol_events = (""")
			int event_index = 0
			String event_mask = ""
			for(event_index = 0; event_index < 5; event_index++)
			{
				if(protocol_events_selection[event_index] == true) {
					if(event_mask != "") {
						event_mask += " |\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"
					}
					event_mask += "(uint32_t)" + protocol_events[event_index]
				}
			}
			out.print(event_mask)
			out.print(""");""")
		}

		/* Write the init function definition */
		out.print("""
/***********************************************************************************************************************
 * API IMPLEMENTATION
 **********************************************************************************************************************/
/* Channel initialization function */
void ${appLabel}_lInit()
{""")
		/* GTab: General */
		out.print("""
  /* Initialize USIC channel in SPI mode */
  XMC_SPI_CH_Init(XMC_SPI${ModuleInst}_CH${ChannelInst}, &${appLabel}_channel_config);""")
		out.print("""
  /* Set the frame and word length */
  XMC_SPI_CH_SetFrameLength(XMC_SPI${ModuleInst}_CH${ChannelInst}, ${appInst.ginteger_frame_length.value}U);
  XMC_SPI_CH_SetWordLength(XMC_SPI${ModuleInst}_CH${ChannelInst}, ${appInst.ginteger_word_length.value}U);""")
		if (appInst.gcombo_data_shift_dir.value == "LSB") {
			out.print("""
  /* Set LSB data shift direction */
  XMC_SPI_CH_SetBitOrderLsbFirst(XMC_SPI${ModuleInst}_CH${ChannelInst});""")
		} else {
			out.print("""
  /* Set MSB data shift direction */
  XMC_SPI_CH_SetBitOrderMsbFirst(XMC_SPI${ModuleInst}_CH${ChannelInst});""")
		}

		if (appInst.gcheck_enable_capture_mode_timer.value == true) {
			out.print("""
  /* Enable the capture mode timer */
  XMC_USIC_CH_EnableTimeMeasurement(XMC_SPI${ModuleInst}_CH${ChannelInst});""")
		}
		if(isTDVEnabled) {
			int type_transmit_data_validation_index = appInst.gcombo_type_transmit_data_validation.options.indexOf(appInst.gcombo_type_transmit_data_validation.value)
			switch(type_transmit_data_validation_index) {
				case 0:
					out.print("""
  /* Enable transmission when TDV = 1 and DX2S = 0 */
  XMC_USIC_CH_SetStartTransmisionMode(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_START_TRANSMISION_ON_TDV_DX2S_0);""")
					break;
				case 1:
					out.print("""
  /* Enable transmission when TDV = 1 and DX2S = 1 */
  XMC_USIC_CH_SetStartTransmisionMode(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_START_TRANSMISION_ON_TDV_DX2S_1);""")
					break;
				case 2:
					out.print("""
  /*Enable transmission when TDV = 1 and the selected edge of the DX2 signal occurs*/
  XMC_USIC_CH_SetInputTriggerCombinationMode(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INPUT_DX2, ${input_combination_mode[appInst.gcombo_transmit_data_validation_trigger_edge.value]});
  XMC_USIC_CH_EnableTBUFDataValidTrigger(XMC_SPI${ModuleInst}_CH${ChannelInst});""")
					break;
			}
		}
		if((isDeviceSlave) && (appInst.gcheck_dx2_event.value == true)) {
			out.print("""
  /* The selected edge of the DX2 signal configuration */
  XMC_USIC_CH_SetInputTriggerCombinationMode(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INPUT_DX2, ${input_combination_mode[appInst.gcombo_transmit_data_validation_trigger_edge_slave.value]});""")
			}
		
		if (isModeDualSPI) {
		 if (isDeviceMaster) {
		out.print("""
  /* Set input source for input stage dx0 (receive pin) */
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN0, (uint8_t)6U);""")
  if(isfamily_4x)
  {
		out.print("""
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN1, (uint8_t)6U);""")
  }
		}else{
		out.print("""
  /* Set input source for input stage dx0 (receive pin) */
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN0, ${appInst.hwres_usic_channel.getRegValue("dx0cr","dx0cr_dsel")}U);""")
if(isfamily_4x)
{
				  out.print("""
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN1, ${appInst.hwres_usic_channel.getRegValue("dx1cr","dx1cr_dsel")}U);""")
}
		}
		} else if (isModeQuadSPI) {
		
		
		if (isDeviceMaster) {
	   out.print("""
  /* Set input source for input stage dx0 (receive pin) */
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN0, (uint8_t)6U);""")
 if(isfamily_4x)
 {
	   out.print("""
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN1, (uint8_t)6U);
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN2, (uint8_t)6U);
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN3, (uint8_t)6U);""")
 }
	   }else{
	   out.print("""
  /* Set input source for input stage dx0 (receive pin) */
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN0, ${appInst.hwres_usic_channel.getRegValue("dx0cr","dx0cr_dsel")}U);""")
if(isfamily_4x)
{
				 out.print("""
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN1, ${appInst.hwres_usic_channel.getRegValue("dx1cr","dx1cr_dsel")}U);
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN2, ${appInst.hwres_usic_channel.getRegValue("dx2cr","dx2cr_dsel")}U);
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN3, ${appInst.hwres_usic_channel.getRegValue("dx3cr","dx3cr_dsel")}U);""")
}
	   }
		
		} else {
			out.print("""
  /* Set input source for input stage dx0 (receive pin) */
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN0, ${appInst.hwres_usic_channel.getRegValue("dx0cr","dx0cr_dsel")}U);""")
			}
		if(isfamily_1x) {
			/* XMC1000 devices can use the DX3 and DX5 input stages as additional sources of input for rx (dx0) */
			out.print("""
  /* Set input source for input stage dx3 (receive pin) */
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN1, ${appInst.hwres_usic_channel.getRegValue("dx3cr","dx3cr_dsel")}U);
  /* Set input source for input stage dx4 (receive pin) */
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN2, ${appInst.hwres_usic_channel.getRegValue("dx4cr","dx4cr_dsel")}U);
  /* Set input source for input stage dx5 (receive pin) */
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_DIN3, ${appInst.hwres_usic_channel.getRegValue("dx5cr","dx5cr_dsel")}U);""")
		}
		if(usesDX1) {
			out.print("""
  /* Set input source for input stage dx1 */
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_SLAVE_SCLKIN, ${appInst.hwres_usic_channel.getRegValue("dx1cr","dx1cr_dsel")}U);""")
		}
		if (isDeviceMaster && isDelayCompensationEnabled) {
			out.print("""
  XMC_SPI_CH_EnableDelayCompensation(XMC_SPI${ModuleInst}_CH${ChannelInst});
  XMC_USIC_CH_ConnectInputDataShiftToPPP(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INPUT_DX1);""")
		}
		if(usesDX2) {
			out.print("""
  /* Set input source for input stage dx2 */
  XMC_SPI_CH_SetInputSource(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_SLAVE_SELIN, ${appInst.hwres_usic_channel.getRegValue("dx2cr","dx2cr_dsel")}U);""")
		}
		if (enableDX1InputInversion) {
				out.print("""
  /* Enable DX2 input polarity inversion */
  XMC_SPI_CH_EnableInputInversion(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_SLAVE_SCLKIN);""")
		}
		if (enableDX2InputInversion) {
			if(isDeviceMaster) {
				out.print("""
  /* Enable DX2 input polarity inversion */""")
			} else { // isDeviceSlave
				out.print("""
  /* Enable SELIN input polarity inversion */""")
			}
			out.print("""
  XMC_SPI_CH_EnableInputInversion(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_INPUT_SLAVE_SELIN);""")
		}
		if (uses_External_Clock) {
			out.print("""
  /* Set the dividers registers to generate the baud rate from an external clock source */
  XMC_SPI_CH_ConfigExternalInputSignalToBRG(XMC_SPI${ModuleInst}_CH${ChannelInst}, ${appInst.ginteger_divider_factor_external_clk.value}U, ${input_combination_mode[appInst.gcombo_external_clock_edge.value]});""")
		}
		if (enableOutputsInversion) {
			out.print("""
  /* Enable output signals polarity inversion */
  XMC_USIC_CH_SetDataOutputMode(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_DATA_OUTPUT_MODE_INVERTED);""")
		}

		if(isDeviceMaster) {
			if(appInst.gcheck_enable_frame_end_mode.value) {
				out.print("""
  /* Enable Frame End Mode */
  XMC_SPI_CH_EnableFEM(XMC_SPI${ModuleInst}_CH${ChannelInst});""")
			} else {
				out.print("""
  /* Disable Frame End Mode */
  XMC_SPI_CH_DisableFEM(XMC_SPI${ModuleInst}_CH${ChannelInst});""")
			}
		}

		/* GTab: Shift Clock */
		out.print("""
  /* Configure the clock polarity and clock delay */""")
		if(isDeviceSlave && isDelayCompensationEnabled_slave) {
			out.print("""
  XMC_SPI_CH_ConfigureShiftClockOutput(XMC_SPI${ModuleInst}_CH${ChannelInst}, ${shift_clock_settings[appInst.gcombo_shift_clock_setting.value]},
                                       XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_DX1);""")
		} else if((isDeviceMaster)||(((isDeviceSlave) && (appInst.gcombo_sclkout_output_slave.value != "None")))){
			out.print("""
  XMC_SPI_CH_ConfigureShiftClockOutput(XMC_SPI${ModuleInst}_CH${ChannelInst}, ${shift_clock_settings[appInst.gcombo_shift_clock_setting.value]},
                                       XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK);""")
		}

		if(isDeviceMaster) {
			/* GTab: Slave Select */
			out.print("""
  /* Disable all Slave Select lines */""")
			out.print("""
  XMC_SPI_CH_DisableSlaveSelect(XMC_SPI${ModuleInst}_CH${ChannelInst});
  /* Establish Slave Select signal polarity */""")
			if(appInst.gcheck_enable_invert_slave_select_signals.value == true) {
				out.print("""
   XMC_SPI_CH_SetSlaveSelectPolarity(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_SLAVE_SEL_INV_TO_MSLS);""")
			} else {
				out.print("""
   XMC_SPI_CH_SetSlaveSelectPolarity(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_SPI_CH_SLAVE_SEL_SAME_AS_MSLS);""")
			}
			out.print("""
  /* Set Select Control */;""")
			if(appInst.gcombo_slave_select_control.value == "Coded") {
				out.print("""
  XMC_SPI_CH_EnableSlaveSelectCodedMode(XMC_SPI${ModuleInst}_CH${ChannelInst});""")
			} else { // appInst.gcombo_slave_select_control.value == "Direct") {
				out.print("""
  XMC_SPI_CH_DisableSlaveSelectCodedMode(XMC_SPI${ModuleInst}_CH${ChannelInst});""")
			}
			out.print("""
  /* Configure the leading/trailing delay for the MSLS signal */
  XMC_SPI_CH_SetSlaveSelectDelay(XMC_SPI${ModuleInst}_CH${ChannelInst}, ${appInst.ginteger_desired_ld_td_value.value}U);""")

			if(appInst.ginteger_desired_iw_nf_value.value > 0)
				out.print("""
  /* Configure the inter word delay for the MSLS signal */
  XMC_SPI_CH_SetInterwordDelaySCLK(XMC_SPI${ModuleInst}_CH${ChannelInst}, ${appInst.ginteger_desired_iw_nf_value.value}U);
  /* Enable inter-word/next-frame delay */
  XMC_SPI_CH_EnableInterwordDelay(XMC_SPI${ModuleInst}_CH${ChannelInst});""")
		}
		
		/* GTab: Events */
		if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_tsien") == 1) {
			int transmit_shift_event_sr = appInst.hwres_usic_channel.getRegValue("inpr","inpr_tsinp")
			out.print("""
  /* Set the service request line for the transmit shift event */
  XMC_USIC_CH_SetInterruptNodePointer(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT, ${transmit_shift_event_sr}U);""")
		}
		if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_tbien") == 1 || appInst.hwres_usic_channel.getRegValue("ccr","ccr_rsien") == 1) {
			int transmit_buffer_event_sr = appInst.hwres_usic_channel.getRegValue("inpr","inpr_tbinp")
			out.print("""
  /* Set the service request line for the transmit buffer event */
  XMC_USIC_CH_SetInterruptNodePointer(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER, ${transmit_buffer_event_sr}U);""")
		}
		if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_rien") == 1) {
			int standard_receive_event_sr = appInst.hwres_usic_channel.getRegValue("inpr","inpr_rinp")
			out.print("""
  /* Set the service request line for the standard receive event */
  XMC_USIC_CH_SetInterruptNodePointer(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INTERRUPT_NODE_POINTER_RECEIVE, ${standard_receive_event_sr}U);""")
		}
		if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_aien") == 1) {
			int alternative_receive_event_sr = appInst.hwres_usic_channel.getRegValue("inpr","inpr_ainp")
			  out.print("""
  /* Set the service request line for the alternative receive event */
  XMC_USIC_CH_SetInterruptNodePointer(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INTERRUPT_NODE_POINTER_ALTERNATE_RECEIVE, ${alternative_receive_event_sr}U);""")
		}
			int protocol_events_sr = appInst.hwres_usic_channel.getRegValue("inpr","inpr_pinp")
			out.print("""
  /* Set the service request line for the Data Lost, Baud Rate Generator and SPI protocol events */
  XMC_USIC_CH_SetInterruptNodePointer(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL, ${protocol_events_sr}U);""")
		if(is_txFIFO_enabled) {
			  if(appInst.hwres_usic_channel.getRegValue("tbctr","tbctr_stbien") == 1) {
				  int standard_transmit_buffer_event_sr = appInst.hwres_usic_channel.getRegValue("tbctr","tbctr_stbinp")
				  out.print("""
  /* Set the service request line for the standard transmit buffer event */
  XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_STANDARD, ${standard_transmit_buffer_event_sr}U);""")
			  }
			  if(appInst.hwres_usic_channel.getRegValue("tbctr","tbctr_tberien") == 1) {
				  int transmit_buffer_error_event_sr = appInst.hwres_usic_channel.getRegValue("tbctr","tbctr_atbinp")
				  out.print("""
  /* Set the service request line for the transmit buffer error event */
  XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE, ${transmit_buffer_error_event_sr}U);""")
			  }
		  }
		  if(is_rxFIFO_enabled) {
			  if(appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_srbien") == 1) {
				  int standard_receive_buffer_event_sr = appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_srbinp")
				  out.print("""
  /* Set the service request line for the standard receive buffer event */
  XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_STANDARD, ${standard_receive_buffer_event_sr}U);""")
			  }
			  if((appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_arbien") == 1) ||
				  (appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_rberien") == 1)) {
				  int alternative_receive_buffer_event_sr = appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_arbinp")
				  out.print("""
  /* Set the service request line for the alternative receive buffer / receive buffer error event */
  XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE, ${alternative_receive_buffer_event_sr}U);""")
			  }
		}
		  if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_rsien") == 1) {
			  out.print("""
  /* Enable the receive start event */
  XMC_USIC_CH_EnableEvent(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_EVENT_RECEIVE_START);""")
		  }
		  if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_tsien") == 1) {
			  out.print("""
  /* Enable the transmit shift event */
  XMC_USIC_CH_EnableEvent(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_EVENT_TRANSMIT_SHIFT);""")
		  }
		  if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_tbien") == 1) {
			  out.print("""
  /* Enable the transmit buffer event */
  XMC_USIC_CH_EnableEvent(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);""")
		  }
		  if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_rien") == 1) {
			  out.print("""
  /* Enable the standard receive event */
  XMC_USIC_CH_EnableEvent(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_EVENT_STANDARD_RECEIVE);""")
		  }
		  if(appInst.hwres_usic_channel.getRegValue("ccr","ccr_aien") == 1) {
			  out.print("""
  /* Enable the alternative event */
  XMC_USIC_CH_EnableEvent(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE);""")
		  }
		  if(is_txFIFO_enabled) {
			  if(appInst.hwres_usic_channel.getRegValue("tbctr","tbctr_stbien") == 1) {
				  out.print("""
  /* Enable the standard transmit buffer event */
  XMC_USIC_CH_TXFIFO_EnableEvent(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);""")
			  }
			  if(appInst.hwres_usic_channel.getRegValue("tbctr","tbctr_tberien") == 1) {
				  out.print("""
  /* Enable the transmit buffer error event */
  XMC_USIC_CH_TXFIFO_EnableEvent(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_TXFIFO_EVENT_CONF_ERROR);""")
			  }
		  }
		  if(is_rxFIFO_enabled) {
			  if(appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_srbien") == 1) {
				  out.print("""
  /* Enable the standard receive buffer event */
  XMC_USIC_CH_RXFIFO_EnableEvent(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD);""")
			  }
			  if(appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_rberien") == 1) {
				  out.print("""
 /* Enable the receive buffer error event */
  XMC_USIC_CH_RXFIFO_EnableEvent(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_RXFIFO_EVENT_CONF_ERROR);""")
			  }
			  if(appInst.hwres_usic_channel.getRegValue("rbctr","rbctr_arbien") == 1) {
				  out.print("""
 /* Enable the alternative receive buffer event */
  XMC_USIC_CH_RXFIFO_EnableEvent(XMC_SPI${ModuleInst}_CH${ChannelInst}, XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE);""")
			  }
		  }
		  if(is_any_protocol_event_enabled) {
			  out.print("""
  /* Enable the SPI protocol-specific events (PCR_ASCMode register) */
  XMC_SPI_CH_EnableEvent(XMC_SPI${ModuleInst}_CH${ChannelInst}, ${appLabel}_enabled_protocol_events);""")
		  }
		
		/* GTab: FIFO */
		if (is_txFIFO_enabled) {
			Integer FIFO_size = appInst.hwres_usic_channel.getRegValue("TBCTR", "tbctr_size")
			Integer FIFO_limit = appInst.ginteger_limit_for_transmit_events.value
			Integer FIFO_data_pointer = appInst.hwres_usic_channel.getRegValue("TBCTR", "tbctr_dptr")
			out.print("""
  /* Configure the transmit FIFO */
  XMC_USIC_CH_TXFIFO_Configure(${appLabel}.channel, ${FIFO_data_pointer}U, ${fifo_size[FIFO_size]}, ${FIFO_limit}U);""")
		}
		if (is_rxFIFO_enabled) {
			Integer FIFO_size = appInst.hwres_usic_channel.getRegValue("RBCTR", "rbctr_size")
			Integer FIFO_limit = appInst.ginteger_limit_for_receive_events.value
			Integer FIFO_data_pointer = appInst.hwres_usic_channel.getRegValue("RBCTR", "rbctr_dptr")
			out.print("""
  /* Configure the receive FIFO */
  XMC_USIC_CH_RXFIFO_Configure(${appLabel}.channel, ${FIFO_data_pointer}U, ${fifo_size[FIFO_size]}, ${FIFO_limit}U);""")
		}
		if((isDeviceMaster) && (appInst.gint_slave_select_lines.value > 0) && (appInst.gcombo_slave_select_control.value == "Direct")){
		out.print("""
  /* Enable the Slave Select 0 Signal */
  XMC_SPI_CH_EnableSlaveSelect(XMC_SPI${ModuleInst}_CH${ChannelInst}, ${appLabel}_slave_select_list[0]);""")
		}
		
		if((appInst.gcombo_mclkout_output_master.value != "None") || (appInst.gcombo_mclkout_output_slave.value != "None")){
			out.print("""
  /* Enable the master clock signal */
  XMC_SPI_CH_EnableMasterClock(XMC_SPI${ModuleInst}_CH${ChannelInst});""")
			
			}
		
out.print("""
}""")
	} /* if the channel resource is available */
} /* For all instances */

out.print("""
/* CODE_BLOCK_END */
""")
